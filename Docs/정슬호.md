#### 2023/7/17(월)

# 📌what i did

- 주간 스프린트 회의 및 지라 이슈 생성 및 조직화 하기
- 컨설턴트 님과 주간 팀 미팅(기능 명세서 역할, 기간, 더 상세히 작성하기)
- 게임 설명 모달 부분에 슬라이드 효과 포함

# 📌issue & solution

## 📖position css 사용 이후 onClick 무응답

### 💢issue

position에 absolute 사용 한뒤에 원하는 슬라이드 효과나 호버 효과가 일어나지 않았다.

### 👀solution

position을 Normal-flow를 벗어나게 하여 다른 태그와 겹치게 되는 경우 적절한 z-index를 필수로 주어서 겹치는 부분에 대해 어떤 태그가 더 앞에 있는 것인지 명확히 해주자, 생각해보면 당연한건데 이걸 못찾아서 1시간을 넘게 헤맸다.

# 📌what i learned

# 📌to do

- JWT를 이용한 인증, 인가 로직 개발

#### 2023/7/18(화)

# 📌what i did

- 주간 스프린트 회의 및 지라 이슈 생성 및 조직화 하기
- 컨설턴트 님과 주간 팀 미팅(기능 명세서 역할, 기간, 더 상세히 작성하기)
- 게임 설명 모달 부분에 슬라이드 효과 포함

# 📌issue & solution

## 📖position css 사용 이후 onClick 무응답

### 💢issue

position에 absolute 사용 한뒤에 원하는 슬라이드 효과나 호버 효과가 일어나지 않았다.

### 👀solution

position을 Normal-flow를 벗어나게 하여 다른 태그와 겹치게 되는 경우 적절한 z-index를 필수로 주어서 겹치는 부분에 대해 어떤 태그가 더 앞에 있는 것인지 명확히 해주자, 생각해보면 당연한건데 이걸 못찾아서 1시간을 넘게 헤맸다.

# 📌what i learned

# 📌to do

- JWT를 이용한 인증, 인가 로직 개발

#### 2023/7/18(화)

# 📌what i did

- signup 로직 및 signup form 입력 값들 검증
- login 로직

# 📌issue & solution

# 📌what i learned

## 📖hooks 사용하기

```typescript
// before
const [email, setEmail] = useState('');
const [isEmailValid, setIsEmailValid] = useState(false);

const [nickname, setNickname] = useState('');
const [isNicknameValid, setIsNicknameValid] = useState(false);

const [password, setPassword] = useState('');
const [isPasswordValid, setIsPasswordValid] = useState(false);

const [confirmPassword, setConfirmPassword] = useState('');
const [isConfirmPasswordValid, setIsConfirmPasswordValid] = useState(false);

const [verificationCode, setVerificationCode] = useState('');
const [isVerificationCodeValid, setIsVerificationCodeValid] = useState(false);

const validateEmail = (email) => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

// Function to validate nickname format
const validateNickname = (nickname) => {
  return nickname.length > 0 && nickname.length <= 10;
};

// Function to validate password format
const validatePassword = (password) => {
  const passwordRegex = /^(?=.*[A-Za-z])(?=.*\d).{6,}$/;
  return passwordRegex.test(password);
};

// Function to handle input changes and update validity state
const handleInputChange = (inputName, inputValue) => {
  switch (inputName) {
    case 'email':
      setEmail(inputValue);
      setIsEmailValid(validateEmail(inputValue));
      break;
    case 'nickname':
      setNickname(inputValue);
      setIsNicknameValid(validateNickname(inputValue));
      break;
    case 'password':
      setPassword(inputValue);
      setIsPasswordValid(validatePassword(inputValue));
      break;
    case 'confirmPassword':
      setConfirmPassword(inputValue);
      setIsConfirmPasswordValid(inputValue === password);
      break;
    case 'verificationCode':
      setVerificationCode(inputValue);
      setIsVerificationCodeValid(inputValue.length === 8);
      break;
    default:
      break;
  }
};
```

- 똑같은 로직 반복되는게 많아서 hooks로 빼서 사용

```typescript
// after

// 커스텀 훅
import { useState } from 'react';

interface returnUseFormField {
  value: string;
  isValid: boolean;
  handleChange: (newValue: string) => void;
  clear: () => void;
}

function useFormField(
  initialValue: string,
  validator: (value: string) => boolean,
): returnUseFormField {
  const [value, setValue] = useState(initialValue);
  const [isValid, setIsValid] = useState(false);

  const handleChange = (newValue: string) => {
    setValue(newValue);
    setIsValid(validator(newValue));
  };

  const clear = () => {
    setValue('');
    setIsValid(false);
  };

  return {
    value,
    isValid,
    handleChange,
    clear,
  };
}

export default useFormField;

// 실제 사용
const emailField = useFormField('', validateEmail);
const nicknameField = useFormField('', validateNickname);
const passwordField = useFormField('', validatePassword);
const confirmPasswordField = useFormField(
  '',
  (value) => value === passwordField.value,
);
```

# 📌to do

- JWT를 이용한 인증, 인가 로직 개발(~ing)

#### 2023/7/19(수)

# 📌what i did

- resetPW 기능 구현
- cookie 관리 및 context api로 전역 상태 관리 로직 만들기
- promise 상태에 따른 react-toast 만들기
- EC2 생성 및 기본 세팅, docker, docker-compose, jenkins 등 설치

# 📌issue & solution

## 📖 test-case 설계

### 💢 issue

프로젝트마다 항상 제일 걱정하는 test-case 결정하기, 소프트웨어공학 강의를 듣고 몇몇의 선정 전략 등을 알고있지만 역시 겨우 7주간 6명이서 빠르게 많은 양을 해야하는 우리 프로젝트에 테스트 코드를 작성하는 것 자체를 고민 중이다, 결국 1순위는 기간내에 프로젝트 완성(최상위 우선순위 기능들 모두 구현하기)이므로..

### 👀 solution

#### 결론

지금까지 생각한 내 결론은 개발을 진행하면서 어떤 기능에대해 1번이상 에러가 발생한다면 해당 기능을 검증할 테스트 코드를 따로 만든다 `ex) 기능 A 또는 어떤 코드 덩어리? A를 완성, 기능 B를 하다가 기능 A가 오류남 => 카운트 1번 해당 오류를 검증 할 테스트 코드 작성 필요`

#### 이유

진짜 최소한의 테스트 케이스를 선정해야 한다는 생각에 나만의 선정방법을 생각해봤다. 코드에 버그가 1번 발생한 부분은 2번, 3번 발생할 확률도 높다는 그런 통계를 소프트웨어공학에서 배운 기록을 근거로 정했다.

#### 단점

- 1번이상 오류라고 했는데 프로젝트 크기가 커지면서 매번 모든 기능이 오류가 난다면 결국 전부 테스트 해야한다, 아직 감이 없어서 너무 테스트 케이스를 많이 작성해야한다면 2번으로 수정 할 수도있다.
- 그냥 내가 만든 테스트 케이스 설계 법이라서 어떤 위험성이 있는지 모름..

# 📌what i learned

- 쿠키 accessToken expire 자체 설정해서 프론트단에서 만료 확인 및 accessToken 요청하기(내가 본 그림에서는 백에서 만료확인)
- context api 사용법 다시 상기하기
- EC2 인스턴스 우분투로 만들고 여러 필요한 프로그램 설치하기, 옛날에 아무것도 모르고 배우던 재미없는 리눅스 명령어를 쓰게 되는날이 올줄 몰랐다.

# 📌to do

- debounce 함수 import 한것 onClick에 적용 시켜 주기
- accessToken 만료시 로직 백엔드와 상의 및 구현하기
